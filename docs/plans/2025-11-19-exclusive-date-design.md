# Exclusive Date Math & Per-Day Calculations Design

## Context & Goals
We need an end-to-end shift from inclusive date ranges to exclusive end dates so the trip spans only the actual travel nights. The core issues today are (1) `generateDaysForDateRange` and every consumer include the departure day, (2) per-day costs divide by an off-by-one day count, and (3) usage toggles let travelers participate on their departure date. That combination produces inflated budgets and confusing UI copy (e.g., 5 days shown for a Jan 1–5 trip). Three approaches surfaced:
1. Keep inclusive storage but subtract one day within every consumer. This minimizes state churn but risks a lifetime of duplicated logic and missed call sites.
2. Convert storage to exclusive (days array, helper utilities, per-day math) while clamping UI inputs and filters accordingly. This centralizes the behavior in a few utilities and lets tests enforce correctness.
3. Hybrid: store inclusive ranges but regenerate the UI-specific day slices on demand each time we render. This avoids migrating stored data but repeats expensive filtering on each render.
I’m choosing option 2 because it makes `TripState.days` authoritative, reduces conditional math in components, and aligns with the plan’s requirement for reusable helpers. We can soft-migrate existing data by letting `generateDaysForDateRange` interpret legacy ranges as exclusive because the stored `endDate` strings already represent the departure date users entered. *Assuming alignment due to autonomous mode; continuing.*

## Helpers & State Mutations
`getDayCount(start, end)` becomes the linchpin. It should parse ISO strings, bail out on invalid inputs, and return `max(0, differenceInDays)` where the difference uses UTC math so DST does not reintroduce +/-1 errors. `generateDaysForDateRange` will call `getDayCount` and loop `count` times, emitting ISO date strings for `start + offset`. This ensures the `days` array only contains active travel days, so `tripState.days` automatically shrinks from five entries to four for a Jan 1–5 trip. We’ll update `updateTripDates` to no-op when inputs are incomplete, reuse existing `Day` objects when available, and continue pruning `usageCosts.days` entries that fall outside the regenerated list. When clamping traveler and expense ranges to the trip window, the comparisons shift to `new Date(value) < new Date(end)` semantics, guaranteeing that anything ending on the  date is already out of range for that day’s usage arrays. `updateTravelerDates` will reference the traveler’s updated dates when cleaning up usage so `date < traveler.endDate` governs removal. These helpers will also export to components (e.g., usage/budget pages and forms) so there is exactly one source of truth for day counts. *Assuming alignment due to autonomous mode; continuing.*

## UI, Validation, and Testing
Setup, travelers, and expense forms will enforce exclusive ranges by (a) preventing submission when `startDate >= endDate`, (b) setting HTML `max` attributes to the day before the trip end for `startDate` inputs, and (c) clamping `endDate` pickers’ `min` values to the day after the chosen start. Daily shared expense previews (in both the form helper text and the list rows) will read from `getDayCount`, show the derived day count, and compute `perDay = totalCost / Math.max(dayCount, 1)` for resilience. Usage filters switch to `date >= startDate && date < endDate`, so the UI stops rendering traveler toggles on their departure date. Budget calculations import the same helper to divide totals consistently, keeping both the traveler detail rows and aggregates honest. For testing, I’ll add Vitest (lightweight, zero-config runner) plus a focused suite in `src/utils/__tests__/tripStateUpdates.test.ts`. The suite will cover `getDayCount` edge cases (valid span, same-day, inverted range), `generateDaysForDateRange` (ensuring day reuse and exclusivity), and traveler clamping (ensuring usage entries vanish when dates tighten). The manual QA checklist will recreate the Jan 1–Jan 5 trip, add a £100 shared expense, verify the UI displays four days at £25/day, and confirm the Usage tab offers no toggles for Jan 5. *Assuming alignment due to autonomous mode; continuing.*
